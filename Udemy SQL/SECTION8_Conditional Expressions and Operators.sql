/* Section 8: Creating Database and Tables */

/*Data Types*/

Booolean: True or False

character: char, varchar and text 

Numeric: integer and floating-point number

Temporal: date, time, timestamp, and interval

UUID: Universally Unique Identifiers

Array: Stores an array of strings, numbers, etc.

JSON

Hstore Key-Value pair

Special types such as network address and geometric data.

you shoudl review the documentation to see limitations of data types:

postgresql.org/docs/current/datatype/html

/* Primary and Foreign Keys*/

Primary key: must be uinique and non-null
Foreign key: a Foreign key is a field or group of fields in a table that uniquely identifies a row in another table.
The table that contains the foreign key is called referencing table or child table
The table to which the foreign key references is called referenced table or parent table
A table can have multiple forign keys depending on its relationships with other tables

i.e. in payment table, payment_id is primary key, and customer_id/staff_id/rental_id are foreign key

how to identify if it is a foreign key?

--under Constraints->golden key symbol is primary key, grey ones are foreign key

/*Constraints*/

Constraints are the rules enforced on data columns on table.
These are used to prevent invalid data from being entered into the database.

1. column constraints:

NOT NULL Constaints: Ensure that a column cannot have null value
UNIQUE Constraints: ensures that all values in the column is distinct
PRIMARY Key
FOREIGN Key
CHECK Conditions: ensures that all values in a column satisfy certain conditions
EXCLUSION Constaints

2. table constraints

CHECK: to check a condition when inserting or updating data.
REFERENCES: to constrain the value stored in the column that must exist in a column in another table
UNIQUE(column_list): forces the values stored in the columns listed inside the parentheses to be unique
PRIMARY KEY (column_list)

/*Create Table*/

CREATE TABLE players(
player_id SERIAL PRIMARY KEY,
age SMALLINT NOT NULL
)；

SERIAL:

1. it will create a sequence object and set the next value generated by the sequence as the default value for the column

2. This is perfect for primary key, because it logs unique integer entries for you automatically upon insertion

3. if a row is later removed, the column with the serial data type will not adjust, marking the fact that a row was removed from the sequence.
i.e. 12357

/*examples*/

CREATE TABLE account (
	user_id SERIAL PRIMARY KEY,
	username VARCHAR(50) UNIQUE NOT NULL,
	password VARCHAR(50) NOT NULL,
	email VARCHAR(250) UNIQUE NOT NULL,
	created_on TIMESTAMP NOT NULL,
	last_login TIMESTAMP
)

CREATE TABLE job (
	job_id SERIAL PRIMARY KEY,
	job_name VARCHAR(200) UNIQUE NOT NULL
)

CREATE TABLE account_job (
	user_id INTEGER REFERENCES account(user_id),
	job_id INTEGER REFERENCES job(job_id),
	hire_date TIMESTAMP
)

/*INSERT*/

INSERT INTO account(username, password, email, createD_on)
VALUES
('Jose', 'password','jose@mail.com',CURRENT_TIMESTAMP)

INSERT INTO job(job_name)
VALUES
('Astronaut')


INSERT INTO job(job_name)
VALUES
('President')

INSERT INTO account_job(user_id, job_id, hire_date)
VALUES
(1,1,CURRENT_TIMESTAMP)

/*below doesn't work because there's no user_id =10 in the account table, remember the foreign key constraints*/
INSERT INTO account_job(user_id, job_id, hire_date)
VALUES
(10,10,CURRENT_TIMESTAMP)
SELECT * FROM account_job

/*UPDATE*/
UPDATE account
SET last_login = CURRENT_TIMESTAMP
WHERE last_login IS NULL

/*overwrite all the last_login entry*/
UPDATE account
SET last_login = CURRENT_TIMESTAMP

/*set based on another column*/

UPDATE account 
SET last_login = created_on

/*Using another table's values(update join)*/

UPDATE TableA
SET original_col = TableB.new_col
From TableB
Where tableA.id = tableB.id

/*return affected rows*/
UPDATE account 
SET last_login = created_on
RETURNING account_id, last_login


UPDATE account_job
SET hire_date = account.created_on
FROM account
WHERE account_job.user_id = account.user_id

UPDATE account
SET last_login = CURRENT_TIMESTAMP
RETURNING email, created_on, last_login

/*Delete*/

/*Remove rows from a table*/
DELETE FROM table 
WHERE row_id = 1

/*Delete rows based on their presence in other tables*/

DELETE FROM tableA 
USING tableB 
WHERE tableA.id = tableB.id

/*Delete all rows from a table*/
DELETE FROM table

i.e.

DELETE FROM job
WHERE job_name = 'cowboy'
RETURNING job_id, job_name


/*ALTER Table*/

/*Adding Columns*/

ALTER TABLE table_name
ADD COLUMN new_col TYPE

/*Remove Columns*/
ALTER TABLE table_name
DROP COLUMN col_name

/*Alter constraints*/

ALTER TABLE table_name
ALTER COLUMN col_name
SET NOT NULL

ALTER TABLE table_name
ALTER COLUMN col_name
ADD CONSTRAINT constraint_name

CREATE TABLE information(
info_id SERIAL PRIMARY KEY,
title VARCHAR(500) NOT NULL,
person VARCHAR(50) NOT NULL UNIQUE
)

ALTER TABLE information
RENAME TO new_info

ALTER TABLE new_info
RENAME COLUMN person TO people


ALTER TABLE new_info
ALTER COLUMN people DROP NOT  NULL

INSERT INTO new_info(title)
VALUES
('SOME NEW TITLE')


/*DROP Table*/

check for existence to avoid error

ALTER TABLE table_name
DROP COLUMN IF EXISTS col_name

/*Check constraints*/

The CHECK constraint allows us to create more customized constraints that adhere to a certain condition.

Such as making sure all inserted integer values fall below a certain threshold.

CREATE TABLE example(
ex_id SEREIAL PRIMARY KEY,
age SMALLINT CHECK(age>21)
parent_age SMAILLINT CHECK(
parent_age > age)
);



/*Assessment Test3 */

/*
Complete the following task:

Create a new database called "School" this database should have two tables: teachers and students.

The students table should have columns for student_id, first_name,last_name, homeroom_number, 
phone,email, and graduation year.

The teachers table should have columns for teacher_id, first_name, last_name,

homeroom_number, department, email, and phone.

The constraints are mostly up to you, but your table constraints do have to consider the following:

 We must have a phone number to contact students in case of an emergency.
 We must have ids as the primary key of the tables
 Phone numbers and emails must be unique to the individual.

 Once you've made the tables, insert a student named Mark Watney (student_id=1) 
 who has a phone number of 777-555-1234 and doesn't have an email. 
 He graduates in 2035 and has 5 as a homeroom number.

 Then insert a teacher names Jonas Salk (teacher_id = 1) 
 who as a homeroom number of 5 and is from the Biology department. 
 His contact info is: jsalk@school.org and a phone number of 777-555-4321.

*/

CREATE TABLE teachers(
teacher_id SERIAL PRIMARY KEY,
first_name VARCHAR(45) NOT NULL,
last_name VARCHAR(45) NOT NULL,
homeroom_number INTEGER,
department VARCHAR(45),
email VARCHAR(20) UNIQUE,
phone VARCHAR(20) UNIQUE
)；

CREATE TABLE students(
student_id SERIAL PRIMARY KEY,
first_name VARCHAR(45) NOT NULL,
last_name VARCHAR(45) NOT NULL,
homeroom_number INTEGER,
email VARCHAR(20) UNIQUE NOT NULL,
phone VARCHAR(115) UNIQUE,
graduationYr INTEGER,
)；

INSERT INTO students(fisrt_name, last_name, homeroom_number, phone, graduationYr)
VALUES
('Mark', 'Watney', 5, '777-555-4321', '2035' )


INSERT INTO teachers(fisrt_name, last_name, homeroom_number, department, email, phone)
VALUES
('Jonas', 'Salk', 5, 'Biology', 'jsalk@school.org','777-555-4321' )





